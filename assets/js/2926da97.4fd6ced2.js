"use strict";(self.webpackChunkdocusaurus_site=self.webpackChunkdocusaurus_site||[]).push([[953],{1991:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>d,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"owners-threshold","title":"Owners & Threshold","description":"Welcome back to the Goki journey! In Chapter 1: SmartWalletWrapper, we learned that the SmartWalletWrapper is your \\"remote control\\" for Goki Smart Wallets, simplifying how you interact with them. But what exactly is a Goki Smart Wallet made of, and how does it know who can do what?","source":"@site/docs/owners-threshold.md","sourceDirName":".","slug":"/owners-threshold","permalink":"/doc_goki/docs/owners-threshold","draft":false,"unlisted":false,"editUrl":"https://github.com/stayrar3/doc_goki/tree/main/docs/owners-threshold.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"SmartWalletWrapper","permalink":"/doc_goki/docs/smart-wallet-wrapper"},"next":{"title":"Timelock","permalink":"/doc_goki/docs/timelock"}}');var o=r(4848),a=r(8453);const s={sidebar_position:3},l="Owners & Threshold",i={},c=[{value:"The Shared Bank Account Dilemma",id:"the-shared-bank-account-dilemma",level:2},{value:"Key Concepts: Owners &amp; Threshold",id:"key-concepts-owners--threshold",level:2},{value:"1. Owners",id:"1-owners",level:3},{value:"2. Threshold",id:"2-threshold",level:3},{value:"Setting Up Owners &amp; Threshold in Goki",id:"setting-up-owners--threshold-in-goki",level:2},{value:"Owners &amp; Threshold in Action",id:"owners--threshold-in-action",level:2},{value:"1. Proposing a Transaction",id:"1-proposing-a-transaction",level:3},{value:"2. Approving a Transaction",id:"2-approving-a-transaction",level:3},{value:"3. Executing a Transaction",id:"3-executing-a-transaction",level:3},{value:"Under the Hood: How Owners &amp; Threshold Work",id:"under-the-hood-how-owners--threshold-work",level:2},{value:"Where the Data Lives",id:"where-the-data-lives",level:3},{value:"How the Program Uses Them",id:"how-the-program-uses-them",level:3},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"owners--threshold",children:"Owners & Threshold"})}),"\n",(0,o.jsxs)(n.p,{children:["Welcome back to the Goki journey! In ",(0,o.jsx)(n.a,{href:"smart-wallet-wrapper",children:"Chapter 1: SmartWalletWrapper"}),", we learned that the ",(0,o.jsx)(n.code,{children:"SmartWalletWrapper"}),' is your "remote control" for Goki Smart Wallets, simplifying how you interact with them. But what exactly is a Goki Smart Wallet made of, and how does it know who can do what?']}),"\n",(0,o.jsxs)(n.p,{children:["That's where ",(0,o.jsx)(n.strong,{children:"Owners & Threshold"}),' come in. These are the foundational security settings of your Goki Smart Wallet, defining its core "multi-signature" (multisig) behavior.']}),"\n",(0,o.jsx)(n.h2,{id:"the-shared-bank-account-dilemma",children:"The Shared Bank Account Dilemma"}),"\n",(0,o.jsxs)(n.p,{children:["Imagine you and your friends decided to open a shared bank account for your club. You don't want just ",(0,o.jsx)(n.em,{children:"anyone"})," to be able to spend money. You want rules:"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Who are the authorized people?"}),' (The "owners")']}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"How many of them need to agree before money can be spent?"}),' (The "threshold")']}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:'On the blockchain, a Goki Smart Wallet solves this exact problem for digital assets. It allows multiple digital "keys" (representing individuals or entities) to control a single wallet, and it enforces rules about how many of those keys must "sign off" on a transaction.'}),"\n",(0,o.jsx)(n.h2,{id:"key-concepts-owners--threshold",children:"Key Concepts: Owners & Threshold"}),"\n",(0,o.jsx)(n.p,{children:"Let's break down these two essential components:"}),"\n",(0,o.jsx)(n.h3,{id:"1-owners",children:"1. Owners"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"owners"})," are simply a ",(0,o.jsx)(n.strong,{children:"list of public keys"}),". Each public key is like a unique digital fingerprint, and it represents someone who has authority over the Smart Wallet. Think of them as the names listed on the shared bank account."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Who they are"}),": Individuals, organizations, or even other smart contracts."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Their role"}),": Each owner has the power to propose transactions or approve existing ones."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"2-threshold",children:"2. Threshold"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"threshold"})," is a ",(0,o.jsx)(n.strong,{children:"number"})," that dictates the minimum number of owners who must agree to a transaction before it can actually happen. It's like the minimum number of signatures required on a check from your shared bank account."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"What it does"}),": Ensures that decisions are not made by a single person, promoting shared governance and security."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Example"}),": If you have 3 owners and a ",(0,o.jsx)(n.code,{children:"threshold"}),' of 2, this is called a "2-of-3" multisig. It means that out of the three owners, any two of them must approve a transaction for it to proceed.']}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"setting-up-owners--threshold-in-goki",children:"Setting Up Owners & Threshold in Goki"}),"\n",(0,o.jsxs)(n.p,{children:["When you create a new Goki Smart Wallet using the ",(0,o.jsx)(n.code,{children:"SmartWalletWrapper"}),", you define its ",(0,o.jsx)(n.code,{children:"owners"})," and ",(0,o.jsx)(n.code,{children:"threshold"})," right from the start."]}),"\n",(0,o.jsx)(n.p,{children:"Let's revisit the example from Chapter 1, focusing on these parameters:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'import { Keypair, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";\nimport { makeSDK } from "./workspace"; // Helper to get the SDK\nimport BN from "bn.js";\n\nconst sdk = makeSDK(); // Our entry point to Goki\n\n// 1. Define our Owners\nconst ownerA = Keypair.generate();\nconst ownerB = Keypair.generate();\nconst ownerC = Keypair.generate();\nconst owners = [ownerA.publicKey, ownerB.publicKey, ownerC.publicKey]; // A list of 3 owner public keys\n\n// 2. Define our Threshold\nconst threshold = new BN(2); // Requires 2 approvals out of these 3 owners\n\nlet smartWalletWrapper; // This will hold our remote control!\n\n// Create a new Smart Wallet using these owners and threshold\nconst { smartWalletWrapper: wrapperInner, tx } = await sdk.newSmartWallet({\n  numOwners: owners.length, // Total number of owners\n  owners,                    // The list of owner public keys\n  threshold,                 // The minimum number of approvals needed\n});\nawait tx.confirm(); // Send the transaction to create the wallet\nsmartWalletWrapper = wrapperInner;\nconsole.log("Smart Wallet created:", smartWalletWrapper.key.toBase58());\n'})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.em,{children:"Explanation"}),": In this code, we first create three unique digital keys (",(0,o.jsx)(n.code,{children:"ownerA"}),", ",(0,o.jsx)(n.code,{children:"ownerB"}),", ",(0,o.jsx)(n.code,{children:"ownerC"}),") to represent our owners. We then list their public keys in the ",(0,o.jsx)(n.code,{children:"owners"})," array. Crucially, we set the ",(0,o.jsx)(n.code,{children:"threshold"})," to ",(0,o.jsx)(n.code,{children:"2"}),'. This means our Smart Wallet is now configured as a "2-of-3" multisig: any transaction will need approvals from at least two of ',(0,o.jsx)(n.code,{children:"ownerA"}),", ",(0,o.jsx)(n.code,{children:"ownerB"}),", or ",(0,o.jsx)(n.code,{children:"ownerC"})," to be executed."]}),"\n",(0,o.jsx)(n.h2,{id:"owners--threshold-in-action",children:"Owners & Threshold in Action"}),"\n",(0,o.jsx)(n.p,{children:"Let's see how these settings play out when we actually use the wallet to send some SOL, just like we did in Chapter 1."}),"\n",(0,o.jsx)(n.h3,{id:"1-proposing-a-transaction",children:"1. Proposing a Transaction"}),"\n",(0,o.jsxs)(n.p,{children:["Any owner can propose a transaction. Let's say ",(0,o.jsx)(n.code,{children:"ownerA"})," proposes sending ",(0,o.jsx)(n.code,{children:"0.1 SOL"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'import { SystemProgram } from "@solana/web3.js";\n// ... (previous code for smartWalletWrapper)\n\nconst recipient = Keypair.generate().publicKey;\nconst amountToSend = 0.1 * LAMPORTS_PER_SOL;\n\n// Owner A proposes the transaction\nconst transferInstruction = SystemProgram.transfer({\n  fromPubkey: smartWalletWrapper.key,\n  toPubkey: recipient,\n  lamports: amountToSend,\n});\n\nconst { transactionKey, tx: proposeTx } =\n  await smartWalletWrapper.newTransaction({\n    proposer: ownerA.publicKey, // Owner A is the proposer\n    instructions: [transferInstruction],\n  });\nproposeTx.signers.push(ownerA);\nawait proposeTx.confirm();\nconsole.log("Transaction proposed:", transactionKey.toBase58());\n'})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.em,{children:"Explanation"}),": Even though ",(0,o.jsx)(n.code,{children:"ownerA"})," proposed the transaction, the ",(0,o.jsx)(n.code,{children:"threshold"})," of 2 has ",(0,o.jsx)(n.em,{children:"not"}),' been met yet. The transaction is just a "proposal" at this stage.']}),"\n",(0,o.jsx)(n.h3,{id:"2-approving-a-transaction",children:"2. Approving a Transaction"}),"\n",(0,o.jsxs)(n.p,{children:["Now, another owner needs to approve the transaction. Let's have ",(0,o.jsx)(n.code,{children:"ownerB"})," approve it."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'// ... (previous code for transactionKey)\n\n// Owner B approves the transaction\nawait smartWalletWrapper\n  .approveTransaction(transactionKey, ownerB.publicKey)\n  .addSigners(ownerB)\n  .confirm();\nconsole.log("Transaction approved by Owner B.");\n\n// Check the current state of the transaction\nconst txState = await smartWalletWrapper.fetchTransaction(transactionKey);\nconsole.log("Approvals needed:", txState.numApprovalsNeeded.toNumber()); // This will be 2\nconsole.log("Approvals received:", txState.numApprovals.toNumber());     // This will be 2\n'})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.em,{children:"Explanation"}),": After ",(0,o.jsx)(n.code,{children:"ownerB"})," approves, the Smart Wallet now has 2 approvals (from ",(0,o.jsx)(n.code,{children:"ownerA"})," and ",(0,o.jsx)(n.code,{children:"ownerB"}),"). Since our ",(0,o.jsx)(n.code,{children:"threshold"})," was set to 2, the transaction has now met the required number of approvals! It's ready to be executed."]}),"\n",(0,o.jsx)(n.h3,{id:"3-executing-a-transaction",children:"3. Executing a Transaction"}),"\n",(0,o.jsxs)(n.p,{children:["Once the threshold is met, any owner (or even someone else, if the transaction is public) can execute it. Let's have ",(0,o.jsx)(n.code,{children:"ownerC"})," execute it."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'// ... (previous code for transactionKey)\n\n// Owner C executes the transaction\nawait smartWalletWrapper\n  .executeTransaction({\n    transactionKey,\n    owner: ownerC.publicKey,\n  })\n  .addSigners(ownerC)\n  .confirm();\nconsole.log("Transaction executed successfully!");\n// The 0.1 SOL has now been sent!\n'})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.em,{children:"Explanation"}),": When ",(0,o.jsx)(n.code,{children:"ownerC"})," attempts to execute, the ",(0,o.jsx)(n.a,{href:"smart-wallet-program",children:"Smart Wallet Program"})," (which we'll explore next) checks if the ",(0,o.jsx)(n.code,{children:"threshold"})," of approvals has been met. Since it has (2 approvals for a threshold of 2), the transaction is allowed to proceed and the SOL is sent."]}),"\n",(0,o.jsx)(n.h2,{id:"under-the-hood-how-owners--threshold-work",children:"Under the Hood: How Owners & Threshold Work"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"owners"})," list and ",(0,o.jsx)(n.code,{children:"threshold"})," value are not just temporary settings; they are fundamental data stored directly on the blockchain as part of your ",(0,o.jsx)(n.code,{children:"SmartWallet"})," account."]}),"\n",(0,o.jsx)(n.h3,{id:"where-the-data-lives",children:"Where the Data Lives"}),"\n",(0,o.jsxs)(n.p,{children:["When you use ",(0,o.jsx)(n.code,{children:"sdk.newSmartWallet"}),", the ",(0,o.jsx)(n.a,{href:"smart-wallet-program",children:"Smart Wallet Program"})," creates a special account on the Solana blockchain for your Smart Wallet. This account permanently stores your ",(0,o.jsx)(n.code,{children:"owners"})," list and ",(0,o.jsx)(n.code,{children:"threshold"})," number."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-mermaid",children:"sequenceDiagram\n    participant User\n    participant SmartWalletWrapper\n    participant SolanaNetwork\n    participant SmartWalletProgram\n    participant SmartWalletAccount\n\n    User->>SmartWalletWrapper: 1. Call newSmartWallet(owners, threshold)\n    SmartWalletWrapper->>SolanaNetwork: 2. Send 'Create Smart Wallet' instruction\n    Note over SolanaNetwork: Instruction processed by Solana blockchain\n    SolanaNetwork->>SmartWalletProgram: 3. Invoke Smart Wallet Program\n    SmartWalletProgram->>SmartWalletAccount: 4. Create & Store (owners, threshold)\n    SmartWalletAccount--\x3e>SmartWalletProgram: 5. Data stored\n    SmartWalletProgram--\x3e>SolanaNetwork: 6. Confirmation\n    SolanaNetwork--\x3e>SmartWalletWrapper: 7. Confirmation\n    SmartWalletWrapper--\x3e>User: 8. Smart Wallet created!\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.em,{children:"Explanation"}),": When you create the Smart Wallet, the ",(0,o.jsx)(n.code,{children:"SmartWalletProgram"})," receives the list of ",(0,o.jsx)(n.code,{children:"owners"})," and the ",(0,o.jsx)(n.code,{children:"threshold"}),". It then securely saves this information into the ",(0,o.jsx)(n.code,{children:"SmartWalletAccount"})," on the blockchain. This data is now the official record for your wallet's security rules."]}),"\n",(0,o.jsx)(n.h3,{id:"how-the-program-uses-them",children:"How the Program Uses Them"}),"\n",(0,o.jsxs)(n.p,{children:["The real power of ",(0,o.jsx)(n.code,{children:"owners"})," and ",(0,o.jsx)(n.code,{children:"threshold"})," comes from how the ",(0,o.jsx)(n.a,{href:"smart-wallet-program",children:"Smart Wallet Program"})," uses them to ",(0,o.jsx)(n.em,{children:"enforce"})," the rules."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsxs)(n.strong,{children:["During ",(0,o.jsx)(n.code,{children:"approveTransaction"})]}),": When an owner approves a transaction, the program checks if the signer is indeed one of the ",(0,o.jsx)(n.code,{children:"owners"})," listed in the ",(0,o.jsx)(n.code,{children:"SmartWallet"})," account. If not, the approval fails."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsxs)(n.strong,{children:["During ",(0,o.jsx)(n.code,{children:"executeTransaction"})]}),": Before executing any instruction, the program checks the current number of approvals on the proposed transaction against the ",(0,o.jsx)(n.code,{children:"threshold"})," stored in the ",(0,o.jsx)(n.code,{children:"SmartWallet"})," account. If ",(0,o.jsx)(n.code,{children:"approvals < threshold"}),", the execution is rejected."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["This is a crucial security feature: the rules are enforced by the blockchain program itself, not just by your local ",(0,o.jsx)(n.code,{children:"SmartWalletWrapper"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Let's look at a simplified code snippet from the core ",(0,o.jsx)(n.a,{href:"smart-wallet-program",children:"Smart Wallet Program"})," written in Rust (",(0,o.jsx)(n.code,{children:"programs/smart-wallet/src/lib.rs"})," and ",(0,o.jsx)(n.code,{children:"programs/smart-wallet/src/state.rs"}),") to see where these values are stored and referenced:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"// Simplified from programs/smart-wallet/src/state.rs\n\n/// A [SmartWallet] is a multisig wallet with Timelock capabilities.\n#[account]\n#[derive(Default, Debug, PartialEq)]\npub struct SmartWallet {\n    // ... other fields ...\n\n    /// Minimum number of owner approvals needed to sign a [Transaction].\n    pub threshold: u64,\n\n    /// Owners of the [SmartWallet].\n    pub owners: Vec<Pubkey>,\n\n    // ... other fields ...\n}\n\nimpl SmartWallet {\n    /// Gets the index of the key in the owners Vec, or error\n    pub fn try_owner_index(&self, key: Pubkey) -> Result<usize> {\n        // This function checks if a given public key is one of the owners.\n        // It returns an error if the key is not found in the 'owners' list.\n        Ok(unwrap_opt!(self.owner_index_opt(key), InvalidOwner))\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.em,{children:"Explanation"}),": The ",(0,o.jsx)(n.code,{children:"SmartWallet"})," struct is how your Smart Wallet's data is organized on the blockchain. Notice it has ",(0,o.jsx)(n.code,{children:"threshold"})," and ",(0,o.jsx)(n.code,{children:"owners"})," fields. The ",(0,o.jsx)(n.code,{children:"try_owner_index"})," function is an example of how the program can check if a given public key (e.g., the one trying to approve a transaction) is actually one of the authorized ",(0,o.jsx)(n.code,{children:"owners"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"And here's a peek at how they are set when the Smart Wallet is created:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"// Simplified from programs/smart-wallet/src/lib.rs\n\n#[program]\npub mod smart_wallet {\n    use super::*;\n\n    /// Initializes a new [SmartWallet] account.\n    pub fn create_smart_wallet(\n        ctx: Context<CreateSmartWallet>,\n        _bump: u8,\n        max_owners: u8, // Max number of owners this wallet can ever have\n        owners: Vec<Pubkey>, // The actual list of owners\n        threshold: u64,      // The required approval count\n        minimum_delay: i64,\n    ) -> Result<()> {\n        let smart_wallet = &mut ctx.accounts.smart_wallet;\n\n        smart_wallet.threshold = threshold; // Program stores the threshold\n        smart_wallet.owners = owners.clone(); // Program stores the owners list\n\n        // ... other initialization ...\n        Ok(())\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.em,{children:"Explanation"}),": In the ",(0,o.jsx)(n.code,{children:"create_smart_wallet"})," function, you can see how the ",(0,o.jsx)(n.code,{children:"threshold"})," and ",(0,o.jsx)(n.code,{children:"owners"})," values passed during creation are directly saved into the ",(0,o.jsx)(n.code,{children:"smart_wallet"})," account on the blockchain. From this point forward, these values define the security parameters of your Goki Smart Wallet."]}),"\n",(0,o.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Owners & Threshold"})," are the bedrock of security and control for your Goki Smart Wallet. They define who has authority and how many agreements are needed for any action. By understanding these concepts, you grasp how shared control is enforced on the blockchain, making Goki ideal for managing collective assets."]}),"\n",(0,o.jsxs)(n.p,{children:["In the next chapter, we'll delve into ",(0,o.jsx)(n.a,{href:"timelock",children:"Timelock"}),", another powerful security feature that adds a time-based delay to transactions, providing an extra layer of safety."]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)("sub",{children:(0,o.jsxs)("sup",{children:[(0,o.jsx)(n.strong,{children:"References"}),": ",(0,o.jsx)(n.a,{href:"https://github.com/GokiProtocol/goki/blob/87aff0569301acd16f3bdcbfec09cae6ba3e62cc/programs/smart-wallet/src/lib.rs",children:"Smart Wallet Program"}),", ",(0,o.jsx)(n.a,{href:"https://github.com/GokiProtocol/goki/blob/87aff0569301acd16f3bdcbfec09cae6ba3e62cc/programs/smart-wallet/src/state.rs",children:"Smart Wallet State"}),", ",(0,o.jsx)(n.a,{href:"https://github.com/GokiProtocol/goki/blob/87aff0569301acd16f3bdcbfec09cae6ba3e62cc/src/sdk.ts",children:"SDK"}),", ",(0,o.jsx)(n.a,{href:"https://github.com/GokiProtocol/goki/blob/87aff0569301acd16f3bdcbfec09cae6ba3e62cc/tests/smartWallet.spec.ts",children:"Tests"})]})})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>l});var t=r(6540);const o={},a=t.createContext(o);function s(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);