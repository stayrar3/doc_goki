"use strict";(self.webpackChunkdocusaurus_site=self.webpackChunkdocusaurus_site||[]).push([[9190],{6399:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"timelock","title":"Timelock","description":"Welcome back to Goki! In the previous chapter, Owners & Threshold, we learned how your Goki Smart Wallet sets up shared control: who can make decisions (owners) and how many need to agree (threshold). These are powerful for security, but what if a decision is approved that turns out to be a mistake or even malicious?","source":"@site/docs/timelock.md","sourceDirName":".","slug":"/timelock","permalink":"/doc_goki/docs/timelock","draft":false,"unlisted":false,"editUrl":"https://github.com/stayrar3/doc_goki/tree/main/docs/timelock.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Owners & Threshold","permalink":"/doc_goki/docs/owners-threshold"},"next":{"title":"Goki SDK","permalink":"/doc_goki/docs/goki-sdk"}}');var r=n(4848),i=n(8453);const o={sidebar_position:4},s="Timelock",l={},c=[{value:"The Bank Account Safety Net",id:"the-bank-account-safety-net",level:2},{value:"Key Concepts: Timelock",id:"key-concepts-timelock",level:2},{value:"Using Timelock in Goki",id:"using-timelock-in-goki",level:2},{value:"1. Setting the Smart Wallet&#39;s Minimum Delay",id:"1-setting-the-smart-wallets-minimum-delay",level:3},{value:"2. Proposing a Transaction with an ETA",id:"2-proposing-a-transaction-with-an-eta",level:3},{value:"3. Attempting to Execute Before Timelock Expires",id:"3-attempting-to-execute-before-timelock-expires",level:3},{value:"4. Executing After Timelock Expires",id:"4-executing-after-timelock-expires",level:3},{value:"Under the Hood: How Timelock Works",id:"under-the-hood-how-timelock-works",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"timelock",children:"Timelock"})}),"\n",(0,r.jsxs)(t.p,{children:["Welcome back to Goki! In the previous chapter, ",(0,r.jsx)(t.a,{href:"owners-threshold",children:"Owners & Threshold"}),", we learned how your Goki Smart Wallet sets up shared control: who can make decisions (owners) and how many need to agree (threshold). These are powerful for security, but what if a decision is approved that turns out to be a mistake or even malicious?"]}),"\n",(0,r.jsxs)(t.p,{children:["This is where ",(0,r.jsx)(t.strong,{children:"Timelock"}),' comes in. It\'s an extra layer of security that acts like a mandatory "cooling-off" period.']}),"\n",(0,r.jsx)(t.h2,{id:"the-bank-account-safety-net",children:"The Bank Account Safety Net"}),"\n",(0,r.jsx)(t.p,{children:"Let's go back to our shared bank account analogy. Imagine you and your friends approve a large payment. But just after everyone agrees, you realize someone made a typo in the amount, or even worse, that the payment address is wrong!"}),"\n",(0,r.jsx)(t.p,{children:'Without a safety net, that money would be sent instantly. But what if the bank had a rule: "Any payment over $1,000 must wait 24 hours before it\'s processed"? That 24-hour window gives you crucial time to detect the error and cancel the payment.'}),"\n",(0,r.jsxs)(t.p,{children:["On the Solana blockchain, ",(0,r.jsx)(t.code,{children:"Timelock"})," provides this exact safety net for your Goki Smart Wallet. It's a delay between when a transaction is approved by the required number of ",(0,r.jsx)(t.a,{href:"owners-threshold",children:"Owners & Threshold"})," and when it can actually be executed on the blockchain."]}),"\n",(0,r.jsx)(t.h2,{id:"key-concepts-timelock",children:"Key Concepts: Timelock"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"Timelock"})," introduces two important values:"]}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Minimum Delay"}),": This is a setting for the ",(0,r.jsx)(t.em,{children:"entire"})," Smart Wallet. It's the shortest amount of time (in seconds) that ",(0,r.jsx)(t.em,{children:"any"})," transaction must wait after being approved, before it can be executed. Think of it as a base security policy for your wallet."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Estimated Time of Arrival (ETA)"}),": This is a specific time (a timestamp in seconds) set for ",(0,r.jsx)(t.em,{children:"each individual transaction"}),". When you propose a transaction, you can specify its ",(0,r.jsx)(t.code,{children:"ETA"}),". The ",(0,r.jsx)(t.code,{children:"ETA"})," must be at least the current time plus the Smart Wallet's ",(0,r.jsx)(t.code,{children:"minimumDelay"}),". A transaction cannot be executed until its ",(0,r.jsx)(t.code,{children:"ETA"})," has passed."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["Why both? The ",(0,r.jsx)(t.code,{children:"minimumDelay"})," ensures that even if you forget to set an ",(0,r.jsx)(t.code,{children:"ETA"})," for a specific transaction, there's always a baseline delay for the entire wallet. The ",(0,r.jsx)(t.code,{children:"ETA"})," gives you flexibility to set longer delays for particularly sensitive operations."]}),"\n",(0,r.jsx)(t.h2,{id:"using-timelock-in-goki",children:"Using Timelock in Goki"}),"\n",(0,r.jsx)(t.p,{children:"Let's see how we can add this crucial safety feature when creating our Smart Wallet and when proposing transactions."}),"\n",(0,r.jsx)(t.h3,{id:"1-setting-the-smart-wallets-minimum-delay",children:"1. Setting the Smart Wallet's Minimum Delay"}),"\n",(0,r.jsxs)(t.p,{children:["You define the ",(0,r.jsx)(t.code,{children:"minimumDelay"})," when you first create your Goki Smart Wallet. This sets a default waiting period for all future transactions."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'import { Keypair, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";\nimport { makeSDK } from "./workspace";\nimport BN from "bn.js";\n\nconst sdk = makeSDK();\nconst ownerA = Keypair.generate();\nconst owners = [ownerA.publicKey];\nconst threshold = new BN(1); // 1-of-1 multisig for simplicity\n\nconst fiveSeconds = new BN(5); // Our minimum delay: 5 seconds\n\nlet smartWalletWrapper;\n\n// Create a new Smart Wallet with a minimum delay\nconst { smartWalletWrapper: wrapperInner, tx } = await sdk.newSmartWallet({\n  numOwners: owners.length,\n  owners,\n  threshold,\n  delay: fiveSeconds, // <-- Here\'s the new \'delay\' parameter!\n});\nawait tx.confirm();\nsmartWalletWrapper = wrapperInner;\nconsole.log("Smart Wallet created with 5s delay:", smartWalletWrapper.key.toBase58());\n'})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.em,{children:"Explanation"}),": We've added a ",(0,r.jsx)(t.code,{children:"delay"})," parameter to ",(0,r.jsx)(t.code,{children:"sdk.newSmartWallet"}),". This tells the Goki program that any transaction for this ",(0,r.jsx)(t.code,{children:"smartWalletWrapper"})," will have a minimum waiting period of 5 seconds after approval."]}),"\n",(0,r.jsx)(t.h3,{id:"2-proposing-a-transaction-with-an-eta",children:"2. Proposing a Transaction with an ETA"}),"\n",(0,r.jsxs)(t.p,{children:["When you propose a new transaction, you can specify an ",(0,r.jsx)(t.code,{children:"eta"})," (Estimated Time of Arrival). This ",(0,r.jsx)(t.code,{children:"eta"})," must be at least the current time plus the ",(0,r.jsx)(t.code,{children:"minimumDelay"})," you set for the wallet."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'import { SystemProgram } from "@solana/web3.js";\n// ... (previous code for smartWalletWrapper)\nimport { sleep } from "@saberhq/token-utils"; // Need this for delay\n\nconst recipient = Keypair.generate().publicKey;\nconst amountToSend = 0.01 * LAMPORTS_PER_SOL;\n\n// Calculate ETA: Current time + Smart Wallet\'s minimum delay + some buffer\nconst smartWalletData = await smartWalletWrapper.reloadData(); // Get current data\nconst minDelay = smartWalletData.minimumDelay.toNumber();\nconst eta = new BN(Date.now() / 1000 + minDelay + 1); // Add 1 second buffer\n\nconst transferInstruction = SystemProgram.transfer({\n  fromPubkey: smartWalletWrapper.key,\n  toPubkey: recipient,\n  lamports: amountToSend,\n});\n\nconst { transactionKey, tx: proposeTx } =\n  await smartWalletWrapper.newTransaction({\n    proposer: ownerA.publicKey,\n    instructions: [transferInstruction],\n    eta, // <-- Here we set the ETA!\n  });\nproposeTx.signers.push(ownerA);\nawait proposeTx.confirm();\nconsole.log("Transaction proposed with ETA:", transactionKey.toBase58());\n'})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.em,{children:"Explanation"}),": We calculate ",(0,r.jsx)(t.code,{children:"eta"})," by taking the current time, adding the Smart Wallet's ",(0,r.jsx)(t.code,{children:"minimumDelay"})," (which is 5 seconds in our example), and a small buffer. This ensures the ",(0,r.jsx)(t.code,{children:"eta"})," is valid. We then pass this ",(0,r.jsx)(t.code,{children:"eta"})," when proposing the transaction. Since our threshold is 1-of-1, ",(0,r.jsx)(t.code,{children:"ownerA"})," proposing also means it's approved."]}),"\n",(0,r.jsx)(t.h3,{id:"3-attempting-to-execute-before-timelock-expires",children:"3. Attempting to Execute Before Timelock Expires"}),"\n",(0,r.jsxs)(t.p,{children:["Now, let's try to execute this transaction immediately. Since we have a ",(0,r.jsx)(t.code,{children:"minimumDelay"})," and an ",(0,r.jsx)(t.code,{children:"eta"}),", it should fail if the ",(0,r.jsx)(t.code,{children:"eta"})," hasn't passed yet."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'// ... (previous code for transactionKey)\n\n// Try to execute immediately\ntry {\n  await smartWalletWrapper\n    .executeTransaction({\n      transactionKey,\n      owner: ownerA.publicKey,\n    })\n    .addSigners(ownerA)\n    .confirm();\n  console.log("This should not be printed!");\n} catch (e) {\n  // We expect this to fail because the timelock hasn\'t passed\n  console.log("Failed to execute (as expected):", (e as Error).message);\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.em,{children:"Explanation"}),": When ",(0,r.jsx)(t.code,{children:"executeTransaction"})," is called, the Goki Smart Wallet program checks if the ",(0,r.jsx)(t.code,{children:"eta"}),' for this specific transaction has passed. Since we\'re trying to execute it immediately, it will likely fail with a "Transaction Not Ready" error.']}),"\n",(0,r.jsx)(t.h3,{id:"4-executing-after-timelock-expires",children:"4. Executing After Timelock Expires"}),"\n",(0,r.jsxs)(t.p,{children:["To successfully execute, we need to wait until the ",(0,r.jsx)(t.code,{children:"eta"})," has passed."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'// ... (previous code for transactionKey, eta)\n\n// Wait until the ETA has passed\nconst timeToWait = eta.toNumber() - (Date.now() / 1000) + 1; // Add 1 sec buffer\nconsole.log(`Waiting for ${timeToWait.toFixed(0)} seconds for Timelock...`);\nawait sleep(timeToWait * 1000); // Sleep function from @saberhq/token-utils\n\n// Now, execute the transaction\nawait smartWalletWrapper\n  .executeTransaction({\n    transactionKey,\n    owner: ownerA.publicKey,\n  })\n  .addSigners(ownerA)\n  .confirm();\nconsole.log("Transaction executed successfully after Timelock!");\n// The 0.01 SOL has now been sent!\n'})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.em,{children:"Explanation"}),": We use a ",(0,r.jsx)(t.code,{children:"sleep"})," function to pause our program until the ",(0,r.jsx)(t.code,{children:"eta"})," is definitely in the past. After waiting, when ",(0,r.jsx)(t.code,{children:"executeTransaction"})," is called again, the Goki program will see that the ",(0,r.jsx)(t.code,{children:"eta"})," condition is met, and the transaction will proceed successfully."]}),"\n",(0,r.jsx)(t.h2,{id:"under-the-hood-how-timelock-works",children:"Under the Hood: How Timelock Works"}),"\n",(0,r.jsxs)(t.p,{children:["Timelock is enforced directly by the ",(0,r.jsx)(t.a,{href:"smart-wallet-program",children:"Smart Wallet Program"})," on the blockchain. Here's a simplified look at what happens:"]}),"\n",(0,r.jsx)(t.mermaid,{value:"sequenceDiagram\n    participant User\n    participant SmartWalletWrapper\n    participant SolanaNetwork\n    participant SmartWalletProgram\n    participant SmartWalletAccount\n    participant TransactionStateAccount\n\n    User->>SmartWalletWrapper: 1. Call newSmartWallet(delay)\n    SmartWalletWrapper->>SolanaNetwork: 2. Send 'Create SW' instruction\n    SolanaNetwork->>SmartWalletProgram: 3. Invoke Smart Wallet Program\n    SmartWalletProgram->>SmartWalletAccount: 4. Store 'minimum_delay'\n    SmartWalletAccount--\x3e>SmartWalletProgram: 5. Data saved\n\n    User->>SmartWalletWrapper: 6. Call newTransaction(eta)\n    SmartWalletWrapper->>SolanaNetwork: 7. Send 'Create TX with Timelock' instruction\n    SolanaNetwork->>SmartWalletProgram: 8. Invoke Smart Wallet Program\n    Note over SmartWalletProgram: 9. Check if eta >= current_time + minimum_delay\n    SmartWalletProgram->>TransactionStateAccount: 10. Store 'eta'\n    TransactionStateAccount--\x3e>SmartWalletProgram: 11. Data saved\n\n    User->>SmartWalletWrapper: 12. Call executeTransaction()\n    SmartWalletWrapper->>SolanaNetwork: 13. Send 'Execute TX' instruction\n    SolanaNetwork->>SmartWalletProgram: 14. Invoke Smart Wallet Program\n    Note over SmartWalletProgram: 15. Check if current_time >= eta\n    SmartWalletProgram--xSolanaNetwork: 16. If not, fail (TransactionNotReady error)\n    SolanaNetwork--xSmartWalletWrapper: 17. Error returned"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.em,{children:"Explanation"}),":"]}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Wallet Creation"}),": When you create a Smart Wallet with a ",(0,r.jsx)(t.code,{children:"delay"}),", the ",(0,r.jsx)(t.code,{children:"SmartWalletWrapper"})," tells the ",(0,r.jsx)(t.a,{href:"smart-wallet-program",children:"Smart Wallet Program"})," to store this ",(0,r.jsx)(t.code,{children:"minimum_delay"})," value directly in your ",(0,r.jsx)(t.code,{children:"SmartWallet"}),"'s data on the blockchain (",(0,r.jsx)(t.a,{href:"smart-wallet-program",children:"SmartWalletAccount"}),")."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Transaction Proposal"}),": When you propose a transaction with an ",(0,r.jsx)(t.code,{children:"eta"}),", the ",(0,r.jsx)(t.code,{children:"SmartWalletWrapper"})," sends a ",(0,r.jsx)(t.code,{children:"create_transaction_with_timelock"})," instruction to the ",(0,r.jsx)(t.a,{href:"smart-wallet-program",children:"Smart Wallet Program"}),". The program first verifies that the ",(0,r.jsx)(t.code,{children:"eta"})," you provided is valid (meaning it's in the future and meets the ",(0,r.jsx)(t.code,{children:"minimum_delay"})," requirement). If valid, it stores this ",(0,r.jsx)(t.code,{children:"eta"})," in the new ",(0,r.jsx)(t.a,{href:"transaction-state-account",children:"Transaction State Account"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Transaction Execution"}),": When anyone tries to ",(0,r.jsx)(t.code,{children:"executeTransaction"}),", the ",(0,r.jsx)(t.a,{href:"smart-wallet-program",children:"Smart Wallet Program"})," checks the ",(0,r.jsx)(t.code,{children:"eta"})," stored in the ",(0,r.jsx)(t.a,{href:"transaction-state-account",children:"Transaction State Account"}),". If the current time on the blockchain (provided by the ",(0,r.jsx)(t.code,{children:"Clock"})," sysvar) is ",(0,r.jsx)(t.em,{children:"before"})," the ",(0,r.jsx)(t.code,{children:"eta"}),", the program stops the execution and returns an error (",(0,r.jsx)(t.code,{children:"TransactionNotReady"}),"). Only once the ",(0,r.jsx)(t.code,{children:"eta"})," has passed will the program allow the transaction to proceed."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Timelock"})," adds a powerful time-based security layer to your Goki Smart Wallet. By introducing a minimum delay between approval and execution, it provides a crucial window to detect and prevent errors or malicious activities, significantly enhancing the safety of your digital assets. This feature is especially valuable for high-value operations where even a small mistake could have large consequences."]}),"\n",(0,r.jsxs)(t.p,{children:["In the next chapter, we'll shift our focus to the ",(0,r.jsx)(t.a,{href:"goki-sdk",children:"Goki SDK"})," itself, understanding how it provides the tools and functions to easily interact with all these Smart Wallet features from your applications."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>s});var a=n(6540);const r={},i=a.createContext(r);function o(e){const t=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);