"use strict";(self.webpackChunkdocusaurus_site=self.webpackChunkdocusaurus_site||[]).push([[2279],{6476:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"program-derived-addresses-pdas","title":"Program Derived Addresses (PDAs)","description":"Welcome back, Goki explorers! In our last chapter, Instruction Execution (CPI), we discovered how your Goki Smart Wallet (through its program) can delegate tasks to other Solana programs by \\"signing\\" on behalf of itself. But how exactly does a program, which doesn\'t have a secret key like a human wallet, manage to \\"sign\\" anything or \\"own\\" accounts?","source":"@site/docs/program-derived-addresses-pdas.md","sourceDirName":".","slug":"/program-derived-addresses-pdas","permalink":"/doc_goki/docs/program-derived-addresses-pdas","draft":false,"unlisted":false,"editUrl":"https://github.com/stayrar3/doc_goki/tree/main/docs/program-derived-addresses-pdas.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"Instruction Execution (CPI)","permalink":"/doc_goki/docs/instruction-execution-cpi"}}');var t=n(4848),a=n(8453);const i={sidebar_position:9},l="Program Derived Addresses (PDAs)",o={},d=[{value:"The Company Vault Analogy",id:"the-company-vault-analogy",level:2},{value:"Key Concepts: The Magic of PDAs",id:"key-concepts-the-magic-of-pdas",level:2},{value:"1. Public Keys vs. PDAs: The &quot;No Private Key&quot; Difference",id:"1-public-keys-vs-pdas-the-no-private-key-difference",level:3},{value:"2. Deterministic Generation: Seeds and Bumps",id:"2-deterministic-generation-seeds-and-bumps",level:3},{value:"3. Only the Program Can Sign",id:"3-only-the-program-can-sign",level:3},{value:"How Goki Uses PDAs",id:"how-goki-uses-pdas",level:2},{value:"1. The <code>SmartWallet</code> Account Itself",id:"1-the-smartwallet-account-itself",level:3},{value:"2. <code>Transaction</code> Accounts",id:"2-transaction-accounts",level:3},{value:"3. Derived Wallets",id:"3-derived-wallets",level:3},{value:"4. Owner Invokers",id:"4-owner-invokers",level:3},{value:"Example: Finding PDA Addresses",id:"example-finding-pda-addresses",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"program-derived-addresses-pdas",children:"Program Derived Addresses (PDAs)"})}),"\n",(0,t.jsxs)(s.p,{children:["Welcome back, Goki explorers! In our last chapter, ",(0,t.jsx)(s.a,{href:"instruction-execution-cpi",children:"Instruction Execution (CPI)"}),', we discovered how your Goki Smart Wallet (through its program) can delegate tasks to other Solana programs by "signing" on behalf of itself. But how exactly does a program, which doesn\'t have a secret key like a human wallet, manage to "sign" anything or "own" accounts?']}),"\n",(0,t.jsxs)(s.p,{children:["This is where ",(0,t.jsx)(s.strong,{children:"Program Derived Addresses (PDAs)"})," come into play. PDAs are a fundamental and magical concept on Solana that allows programs to truly own and control accounts, making powerful applications like Goki possible."]}),"\n",(0,t.jsx)(s.h2,{id:"the-company-vault-analogy",children:"The Company Vault Analogy"}),"\n",(0,t.jsxs)(s.p,{children:["Imagine a large corporation that needs its own bank accounts for various departments: one for payroll, one for operations, one for marketing. They don't want a single person's private key to control these main company accounts. Instead, they want the ",(0,t.jsx)(s.em,{children:"company itself"})," (the corporation's internal rules and systems) to be the sole authority."]}),"\n",(0,t.jsxs)(s.p,{children:['On Solana, a "program" is like this corporation. It\'s a piece of software living on the blockchain. A ',(0,t.jsx)(s.strong,{children:"Program Derived Address (PDA)"}),' is like a "company bank account" that ',(0,t.jsx)(s.strong,{children:"only the program itself"})," can control. It's a special kind of Public Key that doesn't have a private key. This means no one can ever \"steal\" the secret key because it doesn't exist! Only the specific program that ",(0,t.jsx)(s.em,{children:"derived"})," that address can sign for it."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"What problem does it solve?"})," PDAs allow Solana programs to securely manage and own digital assets and data without needing a human to hold a private key for those specific accounts. This is crucial for building complex applications like Goki, where the Smart Wallet itself needs to hold funds and execute transactions based on its multi-signature rules, rather than relying on an external, individual wallet."]}),"\n",(0,t.jsx)(s.p,{children:"In Goki, PDAs are used for several key purposes:"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{style:{textAlign:"left"},children:"PDA Use Case"}),(0,t.jsx)(s.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{style:{textAlign:"left"},children:(0,t.jsxs)(s.strong,{children:["The ",(0,t.jsx)(s.code,{children:"SmartWallet"})," Account"]})}),(0,t.jsxs)(s.td,{style:{textAlign:"left"},children:["The main account that holds your Smart Wallet's configuration (",(0,t.jsx)(s.a,{href:"owners-threshold",children:"Owners & Threshold"}),", ",(0,t.jsx)(s.a,{href:"timelock",children:"Timelock"}),"). It's a PDA, enabling the Goki program to control its own settings."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{style:{textAlign:"left"},children:(0,t.jsxs)(s.strong,{children:[(0,t.jsx)(s.code,{children:"Transaction"})," Accounts"]})}),(0,t.jsxs)(s.td,{style:{textAlign:"left"},children:["Each proposed transaction is stored in its own unique ",(0,t.jsx)(s.a,{href:"transaction-state-account",children:"Transaction State Account"}),", which is also a PDA. This allows the Goki program to manage and update its state securely."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{style:{textAlign:"left"},children:(0,t.jsx)(s.strong,{children:'"Derived Wallets"'})}),(0,t.jsx)(s.td,{style:{textAlign:"left"},children:"Special sub-accounts that act as extensions of the main Smart Wallet. These are PDAs and can hold specific assets, allowing for advanced fund management strategies."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{style:{textAlign:"left"},children:(0,t.jsx)(s.strong,{children:'"Owner Invokers"'})}),(0,t.jsx)(s.td,{style:{textAlign:"left"},children:"Unique PDAs tied to specific owners or functions, allowing for very fine-grained control and delegation within the Smart Wallet's ecosystem."})]})]})]}),"\n",(0,t.jsx)(s.h2,{id:"key-concepts-the-magic-of-pdas",children:"Key Concepts: The Magic of PDAs"}),"\n",(0,t.jsx)(s.p,{children:"Let's break down how these special addresses work."}),"\n",(0,t.jsx)(s.h3,{id:"1-public-keys-vs-pdas-the-no-private-key-difference",children:'1. Public Keys vs. PDAs: The "No Private Key" Difference'}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Regular Public Key"}),": You generate a ",(0,t.jsx)(s.code,{children:"Keypair"}),", which gives you a ",(0,t.jsx)(s.code,{children:"PublicKey"})," and a matching ",(0,t.jsx)(s.code,{children:"PrivateKey"}),". Anyone with the ",(0,t.jsx)(s.code,{children:"PrivateKey"})," can sign for that ",(0,t.jsx)(s.code,{children:"PublicKey"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Program Derived Address (PDA)"}),": This is ",(0,t.jsx)(s.em,{children:"also"})," a ",(0,t.jsx)(s.code,{children:"PublicKey"}),". However, it ",(0,t.jsxs)(s.strong,{children:["does not have a matching ",(0,t.jsx)(s.code,{children:"PrivateKey"})]}),". It cannot be controlled by a human wallet. Instead, it is cryptographically linked to a specific Solana program."]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"2-deterministic-generation-seeds-and-bumps",children:"2. Deterministic Generation: Seeds and Bumps"}),"\n",(0,t.jsxs)(s.p,{children:['How do programs "create" these addresses without a private key? They use a process called ',(0,t.jsx)(s.strong,{children:"deterministic generation"}),". This means the address is always the same if you provide the same inputs."]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Program ID"}),": Every PDA is linked to a specific ",(0,t.jsx)(s.strong,{children:"Program ID"})," (the unique address of the program on Solana, like ",(0,t.jsx)(s.code,{children:"GokivDYuQXPZCWRkwMhdH2h91KpDQXBEmpgBgs55bnpH"})," for the Smart Wallet Program)."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Seeds"}),": These are like ingredients in a recipe. They are a series of bytes (often strings, public keys, or numbers) that are combined with the Program ID. The combination of the Program ID and these seeds ",(0,t.jsx)(s.em,{children:"deterministically"})," generates the PDA. If you use the same Program ID and the same seeds, you will ",(0,t.jsx)(s.em,{children:"always"})," get the same PDA."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Bump"}),": Sometimes, a particular combination of seeds might accidentally result in a valid ",(0,t.jsx)(s.code,{children:"PublicKey"})," that ",(0,t.jsx)(s.em,{children:"does"})," have a corresponding ",(0,t.jsx)(s.code,{children:"PrivateKey"})," (this is extremely rare but possible, known as a ",(0,t.jsx)(s.code,{children:"P-256"}),' curve point). To avoid this, Solana adds an extra byte called a "bump seed" or "bump" to the combination. The system automatically finds a ',(0,t.jsx)(s.code,{children:"bump"})," value that ensures the resulting address ",(0,t.jsx)(s.em,{children:"cannot"})," be signed by a private key. This is why when you derive a PDA, you often get back both the ",(0,t.jsx)(s.code,{children:"PublicKey"})," and its ",(0,t.jsx)(s.code,{children:"bump"})," value."]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["The function used to find a PDA is ",(0,t.jsx)(s.code,{children:"PublicKey.findProgramAddress([seeds], programId)"}),"."]}),"\n",(0,t.jsx)(s.h3,{id:"3-only-the-program-can-sign",children:"3. Only the Program Can Sign"}),"\n",(0,t.jsxs)(s.p,{children:["This is the most crucial part: ",(0,t.jsx)(s.strong,{children:'only the program that deterministically generated a PDA can "sign" for it'}),". When a program wants to act on behalf of a PDA (e.g., transfer SOL from it), it uses a special instruction called ",(0,t.jsx)(s.code,{children:"invoke_signed"}),'. This instruction proves to the Solana runtime that the calling program is indeed the "owner" of the PDA, allowing it to authorize actions for that PDA.']}),"\n",(0,t.jsx)(s.h2,{id:"how-goki-uses-pdas",children:"How Goki Uses PDAs"}),"\n",(0,t.jsx)(s.p,{children:"Let's look at how Goki leverages PDAs for its core functionality:"}),"\n",(0,t.jsxs)(s.h3,{id:"1-the-smartwallet-account-itself",children:["1. The ",(0,t.jsx)(s.code,{children:"SmartWallet"})," Account Itself"]}),"\n",(0,t.jsxs)(s.p,{children:["Your main Goki Smart Wallet account is a PDA. This is fundamental because it means the ",(0,t.jsx)(s.a,{href:"smart-wallet-program",children:"Smart Wallet Program"})," can truly own and control it."]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Seeds"}),": ",(0,t.jsx)(s.code,{children:'["GokiSmartWallet", base_public_key]'}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:'"GokiSmartWallet"'}),": A fixed string, a unique identifier for the Smart Wallet type."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"base_public_key"}),": A public key generated by your regular user wallet. This acts as a unique base for your Smart Wallet."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Why a PDA?"}),": By making the ",(0,t.jsx)(s.code,{children:"SmartWallet"})," account a PDA, the ",(0,t.jsx)(s.a,{href:"smart-wallet-program",children:"Smart Wallet Program"})," can, for instance, transfer SOL directly from this account (once multi-signature conditions are met) using ",(0,t.jsx)(s.code,{children:"invoke_signed"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{id:"2-transaction-accounts",children:["2. ",(0,t.jsx)(s.code,{children:"Transaction"})," Accounts"]}),"\n",(0,t.jsxs)(s.p,{children:["Every time you propose a new transaction using ",(0,t.jsx)(s.code,{children:"smartWalletWrapper.newTransaction"}),", a new ",(0,t.jsx)(s.a,{href:"transaction-state-account",children:"Transaction State Account"})," is created on the blockchain. This account is also a PDA."]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Seeds"}),": ",(0,t.jsx)(s.code,{children:'["GokiTransaction", smart_wallet_public_key, transaction_index]'}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:'"GokiTransaction"'}),": Another fixed string."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"smart_wallet_public_key"}),": The address of your main ",(0,t.jsx)(s.code,{children:"SmartWallet"})," PDA."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"transaction_index"}),": A unique number for each transaction created by that ",(0,t.jsx)(s.code,{children:"SmartWallet"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Why a PDA?"}),": This ensures each transaction proposal has a unique, program-controlled address where its state (instructions, approvals, ",(0,t.jsx)(s.a,{href:"timelock",children:"Timelock"}),") can be stored and updated exclusively by the ",(0,t.jsx)(s.a,{href:"smart-wallet-program",children:"Smart Wallet Program"}),"."]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"3-derived-wallets",children:"3. Derived Wallets"}),"\n",(0,t.jsxs)(s.p,{children:['Goki also allows you to create "derived wallets." These are sub-accounts of your main ',(0,t.jsx)(s.code,{children:"SmartWallet"})," that can hold tokens or SOL separately. They are also PDAs."]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Seeds"}),": ",(0,t.jsx)(s.code,{children:'["GokiSmartWalletDerived", smart_wallet_public_key, wallet_index]'}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:'"GokiSmartWalletDerived"'}),": A fixed string."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"smart_wallet_public_key"}),": The address of your main ",(0,t.jsx)(s.code,{children:"SmartWallet"})," PDA."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"wallet_index"}),": A unique number for each derived wallet you create."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Why a PDA?"}),": This allows the main ",(0,t.jsx)(s.code,{children:"SmartWallet"})," (via the ",(0,t.jsx)(s.a,{href:"smart-wallet-program",children:"Smart Wallet Program"}),") to sign for actions related to these derived wallets. For example, a derived wallet could hold a specific token type, and the ",(0,t.jsx)(s.code,{children:"SmartWallet"})," could approve transactions to send those tokens without directly interacting with the main Smart Wallet's SOL balance."]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"4-owner-invokers",children:"4. Owner Invokers"}),"\n",(0,t.jsx)(s.p,{children:"Owner Invokers are another type of PDA, enabling advanced permissions and interactions."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Seeds"}),": ",(0,t.jsx)(s.code,{children:'["GokiSmartWalletOwnerInvoker", smart_wallet_public_key, invoker_index]'}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:'"GokiSmartWalletOwnerInvoker"'}),": A fixed string."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"smart_wallet_public_key"}),": The address of your main ",(0,t.jsx)(s.code,{children:"SmartWallet"})," PDA."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"invoker_index"}),": A unique number for each owner invoker."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Why a PDA?"}),": These allow specific ",(0,t.jsx)(s.code,{children:"owners"})," (or the ",(0,t.jsx)(s.code,{children:"SmartWallet"})," itself) to delegate very specific, pre-defined actions via CPI, without needing a full multi-signature process for every minor action. It's for more advanced, fine-tuned control scenarios."]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"example-finding-pda-addresses",children:"Example: Finding PDA Addresses"}),"\n",(0,t.jsxs)(s.p,{children:['You won\'t typically "create" PDAs directly as a user; the ',(0,t.jsx)(s.a,{href:"goki-sdk",children:"Goki SDK"})," and ",(0,t.jsx)(s.a,{href:"smart-wallet-program",children:"Smart Wallet Program"})," handle that. However, you can always ",(0,t.jsx)(s.em,{children:"find"})," the address of a PDA given its seeds."]}),"\n",(0,t.jsxs)(s.p,{children:["Let's see how the ",(0,t.jsx)(s.code,{children:"SmartWalletWrapper"})," helps you find the addresses of the main Smart Wallet and its derived addresses:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-typescript",children:'import { Keypair, PublicKey } from "@solana/web3.js";\nimport { makeSDK } from "./workspace";\nimport BN from "bn.js";\n\nconst sdk = makeSDK();\nconst ownerA = Keypair.generate();\nconst owners = [ownerA.publicKey];\nconst threshold = new BN(1);\nconst delaySeconds = new BN(0);\n\n// Use a known base for a reproducible Smart Wallet PDA\nconst baseKeypair = Keypair.generate();\n\n// Create the Smart Wallet. Its address is a PDA!\nconst { smartWalletWrapper, tx } = await sdk.newSmartWallet({\n  numOwners: owners.length,\n  owners,\n  threshold,\n  delay: delaySeconds,\n  base: baseKeypair, // We provide the base keypair here\n});\nawait tx.confirm();\n\nconsole.log("Main Smart Wallet PDA Address:", smartWalletWrapper.key.toBase58());\n// Example Output: Main Smart Wallet PDA Address: B5fD4f...\n\n// Find a Wallet Derived Address for an index (e.g., 0)\nconst [derivedWallet0, derivedBump0] =\n  await smartWalletWrapper.findWalletDerivedAddress(0);\nconsole.log("Derived Wallet (Index 0) PDA Address:", derivedWallet0.toBase58());\n// Example Output: Derived Wallet (Index 0) PDA Address: 2N3xYt...\n\n// Find a Transaction PDA address for a specific index (e.g., 0, first transaction)\nconst [txPDA, txBump] = await smartWalletWrapper.findTransactionAddress(0);\nconsole.log("First Transaction PDA Address:", txPDA.toBase58());\n// Example Output: First Transaction PDA Address: 6PcV3u...\n'})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.em,{children:"Explanation"}),":"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["We first create a new ",(0,t.jsx)(s.code,{children:"SmartWallet"}),". The ",(0,t.jsx)(s.code,{children:"smartWalletWrapper.key"})," property ",(0,t.jsx)(s.em,{children:"is"})," the PDA for your Smart Wallet. It was derived using the ",(0,t.jsx)(s.code,{children:"baseKeypair"})," you provided and the ",(0,t.jsx)(s.code,{children:"GokiSmartWallet"})," string."]}),"\n",(0,t.jsxs)(s.li,{children:["Then, we use ",(0,t.jsx)(s.code,{children:"smartWalletWrapper.findWalletDerivedAddress(0)"}),' to calculate the PDA for a "derived wallet" at index 0. This PDA uses the ',(0,t.jsx)(s.code,{children:"smartWalletWrapper.key"})," (the main Smart Wallet's PDA) and the index ",(0,t.jsx)(s.code,{children:"0"})," as seeds."]}),"\n",(0,t.jsxs)(s.li,{children:["Similarly, ",(0,t.jsx)(s.code,{children:"smartWalletWrapper.findTransactionAddress(0)"})," calculates the PDA for the ",(0,t.jsx)(s.em,{children:"first"})," transaction (",(0,t.jsx)(s.code,{children:"index: 0"}),") associated with this Smart Wallet."]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["These functions within the ",(0,t.jsx)(s.code,{children:"SmartWalletWrapper"})," (which rely on utilities in ",(0,t.jsx)(s.code,{children:"src/wrappers/smartWallet/pda.ts"}),") simply re-run the ",(0,t.jsx)(s.code,{children:"findProgramAddress"})," calculation to show you what the PDA address ",(0,t.jsx)(s.em,{children:"would be"})," for a given set of seeds, even before the account is actually created on-chain."]}),"\n",(0,t.jsx)(s.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Program Derived Addresses (PDAs)"}),' are special public keys on Solana that do not have private keys and can only be signed for by the program that generated them. They are deterministically created from a program\'s ID and a set of "seeds." In Goki, PDAs are fundamental to its architecture, used for the ',(0,t.jsx)(s.code,{children:"SmartWallet"})," account itself, unique ",(0,t.jsx)(s.code,{children:"Transaction"}),' accounts, and special "derived wallets" or "owner invokers." This allows the Goki Smart Wallet Program to securely own assets and manage complex multi-signature operations directly on the blockchain, providing a level of security and flexibility not possible with traditional private key-controlled accounts.']}),"\n",(0,t.jsx)(s.p,{children:"This concludes our deep dive into the core concepts of Goki. You now have a comprehensive understanding of how Goki Smart Wallets operate, from the high-level SDK interface to the intricate on-chain program logic, secured by multi-signature approvals, timelocks, CPI, and the power of PDAs."})]})}function h(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>l});var r=n(6540);const t={},a=r.createContext(t);function i(e){const s=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(a.Provider,{value:s},e.children)}}}]);